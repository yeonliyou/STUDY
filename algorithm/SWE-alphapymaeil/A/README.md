본 README는 SW Expert Academy의 알고리즘 문제들을 푼 log 입니다.

## 2105. 디저트 카페
[2105. 디저트 카페 코드](./2105.py)
- 처음 출발 지점에 다시 도착해야함 => DFS + backtracking
- 처음에는 모든 방향 탐색으로 시작해서 4방향의 사용여부에 따라서 이어서 모든 방향을 탐색하며 방향을 바꾸려고 했는데 답이 제대로 출력이 안되고 백트래킹이 꼬임
- 처음에만 모든 방향으로 탐색 시작하고 => 그 후에는 시계방향으로 돌거나 직진만 하는 좀 더 간단한 로직으로 변경
  - turn 변수 추가해서 컨트롤 해보자
  - 근데 생각해보니까 어차피 윗줄에서 했던 사각형이랑 겹쳐서 결국 한 지점에서 무조건 한방향 시작만 고려하면 됨..
- 정답이 4인 케이스(길이가 1인 정사각형이 답인 경우)만 자꾸 -1로 출력되는 문제가 발생
  - 해당 문제를 해결하고 나니까 답은 -1인데 4가 출력되는 문제 발생 (테케 50개 중에 49개 통과)
    - turn을 조작하는 부분을 수정해서 통과
- 문제 풀때 문제 해석할때 최대한 간결하게 만들 수 있는 요소들은 생각 많이 해주기 ..(ex - 시작 지점에서 굳이 네방향 다 돌필요 없는것)
- 가고 있는 방향이랑 turn 여부를 체크해주는 변수를 분리하는 게 더 좋았을 듯
----------------------

## 1953. 탈주범 검거
[1953. 탈주범 검거 코드](./1953.py)
- 경쟁적 감염 문제랑 비슷하게 어떤 배열 지점에서 계속 퍼져나가는 로직을 짜야할 때는 => 재귀없이 while + queue 가능 (BFS)
- 이때 queue의 append를 튜플형태로 필요한 인자들을 묶어서 넣어줄 수 있음 ex) queue.append((n_row, n_col, time+1))

----------------------

## 1952. 수영장
[1952. 수영장](./1952_after.py)
- 3달권 체크할 때 어떤 하나의 달의 기존 이용권 가격이 세달권보다 비싸면 그때부터 3달권으로 바꿔주게 처음에 코드를 짰었는데 실수함
  - 어떤 하나의 달이 더 싸더라도 다음 달까지 합쳤을 때 세달권보다 더 비싸지면 그것도 3달권으로 바꿔줘야함
  - 그래서 바꿨는데 샘플 테케 10개 중에 7번 케이스만 답이 틀림 (답:1840, 출력:1860) => 하루권 가격이 10이라서 3달권에 포함되는데 포함되지 않는 달이 있는 것 같음.
    - 이 코드는 왼쪽(1월)부터 순서대로 3개월씩 묶음을 확인하고, 가장 먼저 찾은 이득이 되는(혹은 손해가 아닌) 묶음을 선택한 뒤, 그 묶음의 끝에서부터 다시 탐색을 시작하는 탐욕적인(Greedy) 방식으로 동작
    - 문제점은 눈 앞의 이익을 선택하고 더 큰 이익을 놓치게 된다함 (GPT 코멘트)
    - 탐욕 알고리즘적인 접근은 해답을 찾아내지 못하는 경우도 있으니 유의해야 함!
- 이러한 종류의 문제는 1월부터 12월까지 각 월을 마지막으로 했을 때의 최소 비용을 순차적으로 계산해나가는 **동적 계획법(DP)**으로 접근하는 것이 정석적인 풀이 방법임
  - 우리가 3월에 서 있다고 상상해 봅시다. 3월 수영장 요금을 내야 하는 상황입니다.
    1. 이때 우리에게는 몇 가지 선택지가 있습니다. "3월 요금만 따로 낸다"
      : 이 경우, 비용은 (2월까지의 최소 비용) + (3월의 1일권 총합 vs 1달권 중 저렴한 것) 이 됩니다. 즉, 이전 달(2월)까지는 어떻게든 최저가로 왔고, 이번 달(3월)은 이번 달에 맞는 최적의 선택(1일권 or 1달권)을 하겠다는 의미입니다.
    2. "3월을 3개월 이용권의 마지막 달로 묶어서 낸다"
      : 이 경우, 1월, 2월, 3월을 한 번에 3개월권으로 결제하는 것입니다. 비용은 (3개월권 가격) 이 됩니다. (작년 12월까지 비용은 0원이겠죠?)
    => 3월까지의 진짜 최소 비용은 위 두 가지 선택 중 더 저렴한 금액이 됩니다. 이런 식으로 1월부터 차근차근 각 달까지의 최소 비용을 계산해서 저장해두면, 4월, 5월의 최소 비용을 구할 때 이전 계산 결과를 그대로 가져와 쓸 수 있습니다.
----------------------

## 1949. 등산로 조성
- dfs + backtracking
----------------------

## 2115. 벌꿀채취
- 실행시간 : 153m
- 실행 시간을 줄일 수 있었던 이유?
  - 가능한 모든 (r,c) 시작점에 대해 최대 수익을 미리 한 번 계산해서 리스트에 저장. 즉, 조합별로 최대 이익을 계산할 때 처음부터 전체 가능한 조합을 전부 다 계산해서(한번만 계산) 그 값을 재활용
  - 가능한 모든 조합에 대해 벌꿀채취양을 저장할 때 1차원으로 저장

------------------------------

## professional_키순서
[professional_키순서](./professional_키순서.py)
1. 처음 접근법 (딕셔너리) : 딕셔너리로 그래프 만들어서 풀려고 했는데 시간복잡도가 터짐
    - 매 단계마다 height_dict.items()를 전부 훑으면서 target in value를 검사하는 구조임. 이건 사실상 간선 전체를 매번 다시 스캔하는 거라 O(N*M*depth)으로 터져버림
2. 두번째 접근법 (인접 행렬)
    - 순간 queue에 검사할 다음 연속적 학생들 넣을 때 학생번호가 키랑 관련 있는 줄 착각해서 실수함 ..ㅋ 실수주의
    - 중복 계산은 아닌지 체크. 즉, 이 문제에서는 하나의 while 문에서 이미 이전 q에서 검사했던 학생을 또 검사하는건 아닌지 체크


------------------------

## 1249. 보급로
[1249. 보급로](./1249.py)
- [1249_dfs_실패버전](./1249_fail.py) : 처음에 dfs + 방문배열 + 백트래킹으로 풀려고 했는데 4번부터 너무 오래걸려서 런타임 에러 남
- 댓글 보니까 다익스트라로 풀라함 -> bfs + 다익스트라
  - 다익스트라 : 다이나믹 프로그래밍을 활용한 대표적인 최단 경로 탐색 알고리즘
  - 참고 링크 ![Dijkstra](https://song-ift.tistory.com/256)
- 피드백 기록
  - 문제 스타일이나 논리구조가 bfs가 빠른지, dfs가 빠른지 생각해보기
  - 조기종료 조건이 제대로 제 역할을 하고 있는지
  - 델타 상하좌우 설정 순서(?)
  - 해당 탐색 지점 전의 기록을 저장해두면 좋을지 vs 필요 없을지
  - 일반 bfs vs 다익스트라(or DP)가 필요한지 => 각각 간선 가중치가 0/1로 일정한지, 아니면 가중치가 다양하게 존재하는지에 따라 선택하면 됨!
    - ex) 지금 이 문제는 각 좌표에서 다음 좌표로 갈 때 그냥 '갈지/말지'가 아니라 가는 경우 공사시간이 "몇시간"인지가 여러갈래로 나뉨(가중치가 여러개)